---
output: github_document
---


```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  fig.path = "figures/README-",
  out.width = "80%"
)
```

## Manual y ejemplos en español del paquete `speech` <img src='figures/logo.png' align="right" height="180" />

_Nicolás Schmidt, Diego Luján, Juan Andrés Moraes_


### Descripción

El paquete [`speech`](https://nicolas-schmidt.github.io/speech/index.html) permite convertir diarios de sesión del parlamento uruguayo en formato PDF a bases de datos ordenadas en la que cada fila es la intervención de cada uno de los legisladores que interviene en esa sesión. Asimismo, dado que los diarios de sesión muchas veces son imágenes escaneadas y que en el proceso de OCR (reconocimiento óptico de caracteres por su sigla en inglés) se puede perder o dañar la información recuperada, el paquete provee un conjunto de funciones que ayudan a mejorar problemas de este tipo.


##### Característias

> Este paquete ordena todas las intervenciones por sesión de cada uno de los __legisladores__. Esto quiere decir que todas las intervenciones de los *presidentes*, *secretarios*, *ministros* o personas invitadas no identificadas como legisladores no van a ser recuperadas por el algoritmo de recuperación del texto del PDF. Muchas veces puede suceder que el algoritmo no identifique claramente alguna de estas intervenciones (que se identifican y se eliminan). En esos casos la función con la que se pasa de un archivo con extensión `.pdf` a un `data.frame` ([`speech_build()`](https://nicolas-schmidt.github.io/speech/reference/speech_build.html)) tiene un argumento (`rm.error.leg`) que permite incorporar esos casos que se desean eliminar y no fueron identificados por la función.
> Algo similar puede suceder con los legisladores. Una opción es que se use la función y que cada fila de la base de datos sea cada una de las intervenciones de cada legislador en cada momento. Esto quiere decir que se va a tener tantas intervenciones por legislador como cuantas intervenciones haya realizado en esa sesión. La otra opción (usando [`speech_build(., compiler = TRUE)`](https://nicolas-schmidt.github.io/speech/reference/speech_build.html) o [`speech_recompiler()`](https://nicolas-schmidt.github.io/speech/reference/speech_recompiler.html)) es que cada fila de la base de datos sen todas las intervenciones juntas en una misma sesión de cada legislador o legisladora. El problema que puede surgir en con esta opción es que la **unión** de intervenciones se hace por legislador y si en el proceso de recuperación del texto el nombre de algún legislador no aparece escrito correctamente la compilación no va a reconocer a ese legislador que es el mismo, pero está escrito de distintas maneras. Para solucionar estos problemas y poder compilar el paquete tiene una función que permite arreglar este problema: [`speech_legis_replace()`](https://nicolas-schmidt.github.io/speech/reference/speech_recompiler.html).




## Ejemplos

Es importante tener presente que la lectura del texto de los archivos PDF de los diarios de sesión no es siempre clara. Muchos de los diarios de sesión que están en la página [web](https://parlamento.gub.uy/documentosyleyes/documentos/diarios-de-sesion) del parlamento están escaneados. 

En algunas ocasiones antes de convertir el documento PDF que contiene un diario de sesión mediante el uso de la función `speech_build()` va a ser necesario pasar el PDF por un OCR (reconocimiento óptico de caracteres por su sigla en inglés).

Lo primero que hay que hacer en caso de no tener instalado el paquete es instalarlo. En la web del paquete debe verificar cual es la última versión. Si en número de versión de CRAN coincide con la de GitHub instale la de CRAN caso contrario la de GitHub. Esto lo puede verificar las etiquetas (badges) que aparecen abajo a la derecha.


Versión de CRAN:
```r
install.packages("speech")
```
Versión de GitHub:
```r
if (!require("remotes")) install.packages("remotes")
remotes::install_github("Nicolas-Schmidt/speech")
```

Una vez instalado el paquete debe cargarlo en la sesión de trabajo:

```{r}
library(speech)
```

Vamos a ver 3 ejemplos que presentan distintos problemas y niveles de complejidad en su procesamiento:

* El diario de sesión de la Asamblea General de la reapertura democrática: 15 de febrero de 1985.
* Un diario de sesión sobre la creación de los consejos de salarios en 1941.
* Un diario de sesión actual.



#### Ejemplo 1.
###### El primer diario de sesión de la Asamblea General desde la reapertura democrática: 15 de febrero de 1985.


Lo primero que vamos a hacer es buscar la url al diario de sesión con el que queremos trabajar o los descargamos en el argumento `file` ponemos el nombre del archivo pdf con el que lo guardamos. Hecho eso vamos directo a la función principal que es por donde se empieza. Vamos a usarla sin el argumento `compiler` para detectar posibles problemas como los comentados en la sección anterior.


```{r example}
url <- "https://parlamento.gub.uy/documentosyleyes/documentos/diario-de-sesion/asambleageneral/1/IMG/0?width=800&height=600&hl=en_US1&iframe=true&rel=nofollow"

text <- speech::speech_build(file = url)

print(text, n = nrow(text))
```

Si bien la base de datos llamada `text` luce bien (hay legisladores, se reconoció la cámara, la fecha...) se aprecian varios problemas que son producto de la lectura del documento. Este documento está escaneado y hay caracteres que no se leen correctamente: por ejemplo, legislador 7 y 8 parecen ser el mismo, pero al compilar los datos no se van a juntar ya que no están escritos igual; el legislador 25 y 26 es el mismo solo que en el primer caso hay un espacio en medio del apellido de uno de los legisladores. El legislador 13, 23 y 24 parecen ser el mismo que el 14.


También se aprecia que hay un *'legislador'* que no es legislador y que no debería aparecer: el 19: *'PIRIESIDENTE'*.

Comencemos por el ultimo problema. La función `speech_build()` tiene un argumento que permite eliminar 'legisladores' que no queremos en nuestra base de datos: `rm.error.leg`

```{r }
text <- speech::speech_build(file = url, rm.error.leg = "PIRIESIDENTE")

## verificamos que ya no esté

print(text, n = nrow(text))
```

Como se puede ver en la nueva base de datos `text` ya no aparece la fila 19 con los datos anteriores. 

Ahora deberíamos solucionar el problema de los nombres de los legisladores que si queremos que permanezcan en nuestra base de datos y que debemos corregir para poder compilarlos correctamente.

El paquete `speech` tiene una función que permite chequear los nombres de los legisladores ([`speech_check()`](https://nicolas-schmidt.github.io/speech/reference/speech_check.html)) y otra fundción que permite modificar fácilmente los nombres de los legisladores: `speech_legis_replace`.

Vamos a chequear los nombres:
```{r }
speech_check(text)
```
La función `speech_check()` devuelve una lista de nombres ordenados por inicial. Esta función permite visualizar los problemas de un modo más amigable y fácil. Lo que se puede apreciar es que hay distintos tipos de errores: en los legisladores que inicial con **F**, con **P** y con **V**.


Ahora vamos a cambiar los nombres que están mal:

```{r }
text <- speech_legis_replace(text, old = "FElRREIRA Señ",  new = "FERREIRA")
text <- speech_legis_replace(text, old = "V AILLANT",  new = "VAILLANT")
text <- speech_legis_replace(text, old = "PAZ AG",  new = "PAZ AGUIRRE")
text <- speech_legis_replace(text, old = "CORDOSO",  new = "CARDOSO")
```
Con esta función lo que hacemos es modificar la base construida (es decir el objeto `text`) por eso debemos sobrescribirla.

Ahora debemos chequear que los cambios se realizaron de manera correcta:

```{r}
speech_check(text)
```

Una vez que consideramos que ya no hay más cambios por realizar podemos recompilar el diario de sesión. Tenemos que recompilarlo ya que hemos modificado la compilacion inicial.


```{r}
text2 <- speech_recompiler(tidy_speech = text)
print(text2, n = nrow(text2))

```
Una vez que tenemos la base final (`text2`) ahora podemos proceder a usar el paquete [`puy`]() que permite agregar la etiqueta partidaria y el nombre completo de cada legislador.

```{r}
library(puy)

datos <- add_party(text2)
datos
```




#### Ejemplo 3.

Tomamos un diario de sesión reciente y aplicamos el mismo criterio que con los diarios anteriores: usamos `speech_build()` sin compilar para chequear que los nombres de los legisladores sean correctos para luego compilar.

```{r}
url <- "https://parlamento.gub.uy/documentosyleyes/documentos/diario-de-sesion/comisionpermanente/6084/IMG/0?width=800&height=600&hl=en_US1&iframe=true&rel=nofollow"

text <- speech::speech_build(file = url)

print(text, n = nrow(text))
```

Este diario de sesión no presenta problemas en los nombres de los legisladores por lo que podemos perfectamente ir directo a la compilación:

```{r}
text <- speech::speech_build(file = url, compiler = TRUE)

print(text, n = nrow(text))
```

Ahora podemos agregarle la etiqueta partidaria y el nombre completo a los legisladores con el paquete [`puy`]():

```{r}
library(puy)
text <- add_party(text)

print(text, n = nrow(text))
```

Debemos chequear si tenemos la etiqueta partidaria para todos los legisladores:

```{r}
text[, c(1,2, 7:ncol(text))]
```

Como se puede observar hay un solo diputado o senador que la función [`puy::add_party()`]() no logró identificar. Seguramente sea un diputado o senador suplente. Dependiendo del análisis posterior que se quiera hacer es si se busca por fuentes alternativas la filiación de este legislador o se lo puede descartar. La función [`puy::add_party()`]() además de agregar el partido y el nombre completo del legislador agrega una variable a partir de la función del paquete `speech` que hace un conteo de palabras: [`speech_word_count()`](https://nicolas-schmidt.github.io/speech/reference/speech_word_count.html). Esta variable puede ser de utilidad para estos casos por ejemplo, es decir, descartar a este legislador puede que no tenga un impacto significativo ya que solo dice 10 palabras (las cuales seguramente sean: "Si voto...").
